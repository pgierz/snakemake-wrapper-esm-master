"""
Snakemake wrapper for esm_runscripts execution.

This wrapper extracts and executes the .run script content generated by
esm_runscripts without submitting to the batch system. Snakemake handles
resource allocation, and we execute the script content directly.
"""

__author__ = "Paul Gierz"
__copyright__ = "Copyright 2025, Paul Gierz"
__email__ = "paul.gierz@awi.de"
__license__ = "MIT"

import os
import re
import sys
from pathlib import Path

from snakemake.shell import shell

# Extract parameters from Snakemake context
runscript = snakemake.params["runscript"]
task = snakemake.params["task"]
expid = snakemake.params.get("expid", "test")
reuse_config = snakemake.params.get("reuse_config", False)
modify_config = snakemake.params.get("modify_config", None)
current_date = snakemake.params.get("current_date", None)
extra = snakemake.params.get("extra", "")

log = snakemake.log_fmt_shell(stdout=True, stderr=True)


def find_run_script(expid: str, task: str, base_dir: Path = None) -> Path:
    """
    Locate the generated .run file.

    esm_runscripts generates files with pattern:
    {expid}_{cluster}_{datestamp}.run

    Args:
        expid: Experiment ID
        task: Task name (prepcompute/compute/tidy/post)
        base_dir: Base directory to search (default: current directory)

    Returns:
        Path to the .run script

    Raises:
        FileNotFoundError: If run script cannot be found
    """
    search_dir = base_dir if base_dir else Path.cwd()

    # Search in common locations
    search_paths = [
        search_dir / expid / "scripts",
        search_dir / "scripts",
        search_dir,
    ]

    for search_path in search_paths:
        if not search_path.exists():
            continue

        # Pattern: {expid}_*.run
        # Find the most recent one matching the pattern
        pattern = f"{expid}_*.run"
        matches = list(search_path.glob(pattern))

        if matches:
            # Return the most recent one
            most_recent = max(matches, key=lambda p: p.stat().st_mtime)
            return most_recent

    raise FileNotFoundError(
        f"Could not find .run script for expid={expid} in {search_dir}"
    )


def extract_executable_content(run_script_path: Path) -> str:
    """
    Parse .run script and extract executable content.

    This function strips SLURM directives and sbatch commands while keeping
    all executable content including:
    - Shebang
    - Module load commands
    - Export statements
    - Working directory changes
    - Model execution commands

    Args:
        run_script_path: Path to the .run script

    Returns:
        Executable shell script content as string
    """
    with open(run_script_path) as f:
        lines = f.readlines()

    executable_lines = []
    skip_patterns = [
        r'^\s*#SBATCH',  # SLURM directives
        r'^\s*#\$',      # SGE/PBS directives (just in case)
        r'.*sbatch\s+.*\.run',  # sbatch submission commands
    ]

    for line in lines:
        # Check if line should be skipped
        should_skip = any(re.match(pattern, line) for pattern in skip_patterns)

        if not should_skip:
            executable_lines.append(line)

    content = "".join(executable_lines)

    # Ensure we have content
    if not content.strip():
        raise ValueError(f"No executable content found in {run_script_path}")

    return content


def write_executable_script(content: str, output_path: Path):
    """
    Write executable content to a temporary script file.

    Args:
        content: Shell script content
        output_path: Path where script should be written
    """
    with open(output_path, 'w') as f:
        f.write(content)

    # Make executable
    os.chmod(output_path, 0o755)


# Main execution logic

print(f"[esm_runscripts wrapper] Starting for expid={expid}, task={task}", file=sys.stderr)

# Step 1: Generate config/script if needed or if reuse_config=False
if not reuse_config:
    print(f"[esm_runscripts wrapper] Generating configuration with --check", file=sys.stderr)

    cmd = f"esm_runscripts --check {runscript} -t {task} -e {expid}"

    if modify_config:
        cmd += f" -m {modify_config}"

    if current_date:
        cmd += f" -s {current_date}"

    if extra:
        cmd += f" {extra}"

    # Run esm_runscripts in check mode
    shell(f"{cmd} {log}")

    print(f"[esm_runscripts wrapper] Configuration generated", file=sys.stderr)
else:
    print(f"[esm_runscripts wrapper] Reusing existing configuration", file=sys.stderr)

# Step 2: Find the generated .run script
print(f"[esm_runscripts wrapper] Looking for .run script", file=sys.stderr)

try:
    run_script = find_run_script(expid, task)
    print(f"[esm_runscripts wrapper] Found: {run_script}", file=sys.stderr)
except FileNotFoundError as e:
    print(f"[esm_runscripts wrapper] ERROR: {e}", file=sys.stderr)
    sys.exit(1)

# Step 3: Parse and extract executable content
print(f"[esm_runscripts wrapper] Extracting executable content", file=sys.stderr)

try:
    script_content = extract_executable_content(run_script)
except Exception as e:
    print(f"[esm_runscripts wrapper] ERROR: Failed to extract content: {e}", file=sys.stderr)
    sys.exit(1)

# Step 4: Write to temporary executable script
temp_script = run_script.parent / f"{run_script.stem}_snakemake.sh"
write_executable_script(script_content, temp_script)

print(f"[esm_runscripts wrapper] Created executable: {temp_script}", file=sys.stderr)

# Step 5: Execute in Snakemake's allocated environment
# The script content includes:
# - module loads
# - export statements
# - working directory changes
# - actual model execution commands
print(f"[esm_runscripts wrapper] Executing script", file=sys.stderr)

try:
    shell(f"bash {temp_script} {log}")
    print(f"[esm_runscripts wrapper] Execution completed successfully", file=sys.stderr)
except Exception as e:
    print(f"[esm_runscripts wrapper] ERROR: Execution failed: {e}", file=sys.stderr)
    sys.exit(1)
finally:
    # Clean up temporary script
    if temp_script.exists():
        temp_script.unlink()
