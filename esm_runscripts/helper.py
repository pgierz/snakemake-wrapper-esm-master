"""
Helper functions for Snakefile resource declaration.

This module provides utilities for extracting Snakemake resources from
esm_runscripts configuration files. Users import and call get_resources()
in their Snakefiles to automatically determine resource requirements.

Example:
    from esm_runscripts_wrapper import get_resources

    rule compute_phase:
        params:
            runscript="awicm.yaml",
            task="compute",
            expid="exp001"
        resources:
            **get_resources("awicm.yaml", "compute", expid="exp001")
        wrapper: "file://path/to/esm_runscripts"
"""

__author__ = "Paul Gierz"
__copyright__ = "Copyright 2025, Paul Gierz"
__email__ = "paul.gierz@awi.de"
__license__ = "MIT"

import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Dict, Optional

try:
    import herrkunft as yaml
except ImportError:
    # Fallback to PyYAML if herrkunft not available
    import yaml


def get_resources(
    runscript: str,
    task: str,
    expid: str = "test",
    modify_config: Optional[str] = None,
    base_dir: Optional[str] = None,
    **extra_args
) -> Dict[str, int]:
    """
    Extract Snakemake resources by running esm_runscripts --check.

    This function runs esm_runscripts in check mode to generate the
    finished_config.yaml file, then parses it to extract resource
    requirements for Snakemake.

    Args:
        runscript: Path to ESM runscript YAML file
        task: Phase to execute (prepcompute/compute/tidy/post)
        expid: Experiment ID (default: "test")
        modify_config: Optional path to config override file
        base_dir: Optional base directory for experiment (default: current dir)
        **extra_args: Additional arguments passed to esm_runscripts

    Returns:
        Dictionary with Snakemake resource keys:
        - nodes: Number of compute nodes
        - tasks: Number of tasks/cores
        - mem_mb: Memory in megabytes
        - runtime: Runtime in minutes
        - partition: SLURM partition name

    Raises:
        FileNotFoundError: If runscript doesn't exist
        subprocess.CalledProcessError: If esm_runscripts --check fails
        ValueError: If finished_config.yaml cannot be parsed
    """
    # Validate runscript exists
    runscript_path = Path(runscript).resolve()
    if not runscript_path.exists():
        raise FileNotFoundError(f"Runscript not found: {runscript}")

    # Build command
    cmd = [
        "esm_runscripts",
        "--check",
        str(runscript_path),
        "-t", task,
        "-e", expid,
    ]

    if modify_config:
        cmd.extend(["-m", modify_config])

    # Add any extra arguments
    for key, value in extra_args.items():
        cmd.extend([f"--{key}", str(value)])

    # Run esm_runscripts --check to generate finished_config.yaml
    print(f"Extracting resources: {' '.join(cmd)}", file=sys.stderr)

    try:
        result = subprocess.run(
            cmd,
            check=True,
            capture_output=True,
            text=True,
            cwd=base_dir or os.getcwd()
        )
    except subprocess.CalledProcessError as e:
        print(f"Error running esm_runscripts --check:", file=sys.stderr)
        print(e.stderr, file=sys.stderr)
        raise

    # Find and load finished_config.yaml
    config_path = _find_finished_config(expid, task, base_dir)

    with open(config_path) as f:
        config = yaml.safe_load(f)

    # Extract and return resources
    resources = _extract_resources_from_config(config)

    print(f"Extracted resources: {resources}", file=sys.stderr)

    return resources


def _find_finished_config(
    expid: str,
    task: str,
    base_dir: Optional[str] = None
) -> Path:
    """
    Locate the finished_config.yaml file generated by esm_runscripts.

    Args:
        expid: Experiment ID
        task: Task/phase name
        base_dir: Optional base directory to search

    Returns:
        Path to finished_config.yaml

    Raises:
        FileNotFoundError: If config file cannot be found
    """
    search_dir = Path(base_dir) if base_dir else Path.cwd()

    # Pattern: {expid}_finished_config.yaml or {expid}_{model}_finished_config.yaml
    # Search in common locations:
    # 1. {base_dir}/{expid}/config/
    # 2. {base_dir}/config/
    # 3. Current directory

    search_paths = [
        search_dir / expid / "config",
        search_dir / "config",
        search_dir,
    ]

    for search_path in search_paths:
        if not search_path.exists():
            continue

        # Try exact match first
        exact_match = search_path / f"{expid}_finished_config.yaml"
        if exact_match.exists():
            return exact_match

        # Try pattern match (for coupled models)
        pattern = f"{expid}_*finished_config.yaml"
        matches = list(search_path.glob(pattern))

        if matches:
            # Return the most recent one
            return max(matches, key=lambda p: p.stat().st_mtime)

    raise FileNotFoundError(
        f"Could not find finished_config.yaml for expid={expid} in {search_dir}"
    )


def _extract_resources_from_config(config: dict) -> Dict[str, int]:
    """
    Extract Snakemake resources from finished_config.yaml.

    Args:
        config: Parsed YAML configuration dict

    Returns:
        Dictionary with Snakemake resource specifications
    """
    general = config.get("general", {})
    computer = config.get("computer", {})

    resources = {
        "nodes": general.get("resubmit_nodes", 1),
        "tasks": general.get("resubmit_tasks", 1),
        "mem_mb": _parse_memory(computer.get("memory_per_task", "1G")),
        "runtime": _parse_time(general.get("run_time", "01:00:00")),
    }

    # Add partition if specified
    if "partition" in computer:
        resources["partition"] = computer["partition"]

    # Add account if specified
    if "account" in computer:
        resources["account"] = computer["account"]

    return resources


def _parse_memory(mem_str: str) -> int:
    """
    Convert memory string to megabytes.

    Args:
        mem_str: Memory specification (e.g., "200G", "180000M", "1024K")

    Returns:
        Memory in megabytes

    Examples:
        >>> _parse_memory("200G")
        204800
        >>> _parse_memory("1024M")
        1024
        >>> _parse_memory("512K")
        0
    """
    if isinstance(mem_str, (int, float)):
        return int(mem_str)

    mem_str = str(mem_str).strip().upper()

    # Match number and unit
    match = re.match(r'([0-9.]+)\s*([KMGT]?B?)', mem_str)
    if not match:
        raise ValueError(f"Cannot parse memory: {mem_str}")

    value = float(match.group(1))
    unit = match.group(2)

    # Convert to MB
    if unit.startswith('K'):
        return int(value / 1024)
    elif unit.startswith('M') or not unit:
        return int(value)
    elif unit.startswith('G'):
        return int(value * 1024)
    elif unit.startswith('T'):
        return int(value * 1024 * 1024)
    else:
        raise ValueError(f"Unknown memory unit: {unit}")


def _parse_time(time_str: str) -> int:
    """
    Convert time string to minutes.

    Args:
        time_str: Time specification (HH:MM:SS or minutes)

    Returns:
        Time in minutes

    Examples:
        >>> _parse_time("12:00:00")
        720
        >>> _parse_time("01:30:00")
        90
        >>> _parse_time("720")
        720
    """
    if isinstance(time_str, (int, float)):
        return int(time_str)

    time_str = str(time_str).strip()

    # Try parsing as integer (already in minutes)
    try:
        return int(time_str)
    except ValueError:
        pass

    # Parse HH:MM:SS or MM:SS format
    parts = time_str.split(":")

    if len(parts) == 3:
        hours, minutes, seconds = map(int, parts)
        return hours * 60 + minutes + (1 if seconds > 0 else 0)
    elif len(parts) == 2:
        minutes, seconds = map(int, parts)
        return minutes + (1 if seconds > 0 else 0)
    else:
        raise ValueError(f"Cannot parse time: {time_str}")
